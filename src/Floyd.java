/*
 * This program is made for CPCS-324 Algorithms& Data Structures II cource project - phase 1
 * It computes the all the shortest paths according to the distance matrix 
 * using Floyd Algorithm
 * Group members: Zainab Aljifri, Lubna Alharthy and Rahaf Aljohani
 */

import java.awt.Color;
import java.awt.Image;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

public class Floyd extends javax.swing.JFrame {

    // global variables declaration 
    static final int INF = Integer.MAX_VALUE;
                         //  A    B    C    D    E    F    G    H    I    J 
    static int[][] mat = { { 0 , 10 , INF, INF, INF,  5 , INF, INF, INF, INF},  // A
                           {INF,  0 ,  3 , INF,  3 , INF, INF, INF, INF, INF},  // B
                           {INF, INF,  0 ,  4 , INF, INF, INF,  5 , INF, INF},  // C
                           {INF, INF, INF,  0 , INF, INF, INF, INF,  4 , INF},  // D
                           {INF, INF,  4 , INF,  0 , INF,  2 , INF, INF, INF},  // E
                           {INF,  3 , INF, INF, INF,  0 , INF, INF, INF,  2 },  // F
                           {INF, INF, INF,  7 , INF, INF,  0 , INF, INF, INF},  // G
                           {INF, INF, INF,  4 , INF, INF, INF,  0 ,  3 , INF},  // H
                           {INF, INF, INF, INF, INF, INF, INF, INF,  0 , INF},  // I
                           {INF,  6 , INF, INF, INF, INF,  8 , INF, INF,  0 },  // J    
                        };
    static int n = mat.length;
    static char[] ver = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};

    /**
     * Creates new form Floyd
     */
    public Floyd() {
        initComponents();
        // centering the gui frame
        setLocationRelativeTo(null);
        // set the fame icon
        setIconImage(new ImageIcon("neural2.png").getImage());
        // setting an image inside the frame
        ImageIcon ico = new ImageIcon("graph.png");
        Image img = ico.getImage();
        Image imgScale = img.getScaledInstance(lbl_pic.getWidth(), lbl_pic.getHeight(), Image.SCALE_SMOOTH);
        ImageIcon scaledIcon = new ImageIcon(imgScale);
        lbl_pic.setIcon(scaledIcon);  // set the game image to the label
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        background = new javax.swing.JPanel();
        title = new javax.swing.JLabel();
        lbl_graph = new javax.swing.JLabel();
        lbl_pic = new javax.swing.JLabel();
        lbl_mat = new javax.swing.JLabel();
        matrix = new javax.swing.JTable();
        lbl_d = new javax.swing.JLabel();
        cb_ver = new javax.swing.JComboBox<>();
        lbl_ver = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 255, 255));
        setResizable(false);

        background.setBackground(new java.awt.Color(255, 255, 255));

        title.setFont(new java.awt.Font("Consolas", 1, 24)); // NOI18N
        title.setForeground(new java.awt.Color(0, 102, 153));
        title.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        title.setText("_________Welcome to Floyd-Warshall Solver_________");

        lbl_graph.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        lbl_graph.setForeground(new java.awt.Color(153, 153, 153));
        lbl_graph.setText("Graph");

        lbl_mat.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        lbl_mat.setForeground(new java.awt.Color(153, 153, 153));
        lbl_mat.setText("Distance matrix that indicates the length of the shortest paths");

        matrix.setBackground(new java.awt.Color(255, 255, 255));
        matrix.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        matrix.setForeground(new java.awt.Color(0, 153, 153));
        matrix.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4", "Title 5", "Title 6", "Title 7", "Title 8", "Title 9", "Title 10", "Title 11"
            }
        ));
        matrix.setRowHeight(30);

        lbl_d.setFont(new java.awt.Font("Consolas", 1, 24)); // NOI18N
        lbl_d.setForeground(new java.awt.Color(0, 102, 153));
        lbl_d.setText("D");

        cb_ver.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J" }));
        cb_ver.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cb_verActionPerformed(evt);
            }
        });

        lbl_ver.setFont(new java.awt.Font("Consolas", 1, 18)); // NOI18N
        lbl_ver.setForeground(new java.awt.Color(102, 102, 102));
        lbl_ver.setText("Choose any vertex");

        javax.swing.GroupLayout backgroundLayout = new javax.swing.GroupLayout(background);
        background.setLayout(backgroundLayout);
        backgroundLayout.setHorizontalGroup(
            backgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(title, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, backgroundLayout.createSequentialGroup()
                .addGroup(backgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(backgroundLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(matrix, javax.swing.GroupLayout.PREFERRED_SIZE, 616, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(backgroundLayout.createSequentialGroup()
                        .addGap(215, 215, 215)
                        .addComponent(lbl_ver)
                        .addGap(33, 33, 33)
                        .addComponent(cb_ver, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(backgroundLayout.createSequentialGroup()
                        .addContainerGap(42, Short.MAX_VALUE)
                        .addComponent(lbl_mat, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addGap(37, 37, 37))
            .addGroup(backgroundLayout.createSequentialGroup()
                .addGroup(backgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(backgroundLayout.createSequentialGroup()
                        .addGap(309, 309, 309)
                        .addComponent(lbl_graph))
                    .addGroup(backgroundLayout.createSequentialGroup()
                        .addGap(73, 73, 73)
                        .addComponent(lbl_pic, javax.swing.GroupLayout.PREFERRED_SIZE, 547, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(backgroundLayout.createSequentialGroup()
                        .addGap(319, 319, 319)
                        .addComponent(lbl_d)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        backgroundLayout.setVerticalGroup(
            backgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(backgroundLayout.createSequentialGroup()
                .addComponent(title, javax.swing.GroupLayout.PREFERRED_SIZE, 62, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lbl_graph)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lbl_pic, javax.swing.GroupLayout.PREFERRED_SIZE, 252, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(lbl_mat)
                .addGap(18, 18, 18)
                .addComponent(lbl_d)
                .addGap(27, 27, 27)
                .addComponent(matrix, javax.swing.GroupLayout.PREFERRED_SIZE, 330, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(37, 37, 37)
                .addGroup(backgroundLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cb_ver, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lbl_ver))
                .addContainerGap(28, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(background, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(background, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // actions performed when selected a vertex from the combobox
    private void cb_verActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cb_verActionPerformed
        // TODO add your handling code here:
        // define snd save the selected vertex
        int selected_ver = 0;
        if (evt.getSource() == cb_ver) {
            for (int i = 0; i < ver.length; i++) {
                if (cb_ver.getSelectedIndex() == i) {
                    selected_ver = i;
                }
            }
            // a new frame is created
            JFrame f = new JFrame("Shortest path");
            // set the frame size
            f.setSize(400, 300);
            // show the frame
            f.setVisible(true);
            // centering the gui frame
            f.setLocationRelativeTo(null);
            // set the fame icon
            f.setIconImage(new ImageIcon("neural2.png").getImage());
            // change the frame backgroud to "white"
            f.getContentPane().setBackground(Color.white);
            // store the path from the selected vertex to every other vertex in the graph
            // *the html is used for the text format(for the new line to be specific)*
            String path = "<html>";
            for (int i = 0; i < n; i++) {
                if (mat[selected_ver][i] != INF) {
                    path += "The shortest path from " + ver[selected_ver] + " to " + ver[i] + " is " + mat[selected_ver][i] + "<br/>";
                } else {
                    path += "There is no directed path from " + ver[selected_ver] + " to " + ver[i] + "<br/>";
                }
            }
            // create a label
            JLabel text = new javax.swing.JLabel(path + "</html>");
            // set the font& color of the label
            text.setFont(new java.awt.Font("Consolas", 1, 16));
            text.setForeground(new java.awt.Color(0, 102, 153));
            // add the label to the new created frame
            f.add(text);
        }
    }//GEN-LAST:event_cb_verActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Floyd.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Floyd.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Floyd.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Floyd.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        // one of the following methods is chosen, and the other is commented out
        // 1. GUI OUTPUT (used to present the distance matrices from D(0)-D(10),
        //    and it is made specially for this problem
        // ---------------------------------------------------------------------
        Floyds_gui();
        // ---------------------------------------------------------------------

        // 2. CONSOLE OUTPUT (used to present the distance matrices 
        //    from D(0)-D(N), where n can be any number,
        //    if n>52 then the printing statements containing 
        //    ver array is commented out to avoid errors)
        // ---------------------------------------------------------------------
//        Floyds_con(); 
        // ---------------------------------------------------------------------
    }

    public static void Floyds_gui() {
        // show the frame
        new Floyd().setVisible(true);
        // unwanted widgets are not shown for the current time
        cb_ver.setVisible(false);
        lbl_ver.setVisible(false);
        // printing D(0) which is equivalent to the adj matrix
        lbl_d.setText("D(0)");
        for (int i = 0; i < n; i++) {
            // printing the vertices labels
            matrix.setValueAt(ver[i], i + 1, 0);
            matrix.setValueAt(ver[i], 0, i + 1);
            for (int j = 0; j < n; j++) {
                matrix.setValueAt(mat[i][j] == INF ? "∞" : mat[i][j], i + 1, j + 1);
            }
        }
        // pause the execution for 1000ms(=1s) in order to observe the changes on the matrix
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            Logger.getLogger(Floyd.class.getName()).log(Level.SEVERE, null, ex);
        }
        // BEGINNING OF FLOYD ALGORITHM
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                lbl_d.setText("D(" + (i + 1) + ")");
                for (int k = 0; k < n; k++) {
                    if (mat[j][k] > mat[j][i] + mat[i][k] && mat[j][i] != INF && mat[i][k] != INF) {
                        mat[j][k] = mat[j][i] + mat[i][k];
                    }
                    matrix.setValueAt(mat[j][k] == INF ? "∞" : mat[j][k], j + 1, k + 1);
                }
            }
            // pause the execution for 1000ms(=1s) in order to observe the changes on the matrix
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                Logger.getLogger(Floyd.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        // END OF THE ALGORITHM
        // show label and combobox widgets after the algorithm is done
        lbl_ver.setVisible(true);
        cb_ver.setVisible(true);
    }

    public static void Floyds_con() {
        System.out.println("------------------- WELCOME TO FLOYD-WARSHALL ALGORITHM SOLVER -------------------");
        System.out.println("> The following matrices shows the shortest path for each iteration\n");
        // printing D(0) which is equivalent to the adj matrix
        System.out.print("D(0)=\n\t");
        for (int c = 0; c < n; c++) {
            // printing the vertices labels 
            System.out.print(ver[c] + "\t");
        }
        System.out.println();
        for (int i = 0; i < n; i++) {
            // printing the vertices labels
            System.out.print(ver[i] + "\t");
            for (int j = 0; j < n; j++) {
                System.out.print((mat[i][j] == INF ? "∞" : mat[i][j]) + (n - 1 == j ? "\n" : "\t"));
            }
        }
        System.out.println();
        // BEGINNING OF FLOYD ALGORITHM
        for (int i = 0; i < n; i++) {
            System.out.print("D(" + (i + 1) + ")=\n\t");
            // extra loop for printing the vertices labels (not needed for computations) 
            for (int c = 0; c < n; c++) {
                System.out.print(ver[c] + "\t");
            }
            System.out.println();
            for (int j = 0; j < n; j++) {
                System.out.print(ver[j] + "\t");
                for (int k = 0; k < n; k++) {
                    if (mat[j][k] > mat[j][i] + mat[i][k] && mat[j][i] != INF && mat[i][k] != INF) {
                        mat[j][k] = mat[j][i] + mat[i][k];
                    }
                    System.out.print((mat[j][k] == INF ? "∞" : mat[j][k]) + (n - 1 == k ? "\n" : "\t"));
                }
            }
            System.out.println("");
        }
        // END OF THE ALGORITHM
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel background;
    private static javax.swing.JComboBox<String> cb_ver;
    private static javax.swing.JLabel lbl_d;
    private javax.swing.JLabel lbl_graph;
    private javax.swing.JLabel lbl_mat;
    private javax.swing.JLabel lbl_pic;
    private static javax.swing.JLabel lbl_ver;
    private static javax.swing.JTable matrix;
    private javax.swing.JLabel title;
    // End of variables declaration//GEN-END:variables
}
